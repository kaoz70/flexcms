## Internal Requests

Cartalyst's API package makes it dead-simple to make internal requests to your API within your application. Each method acts virtually identically and takes the same arguments. This allows for an easy way to integrate API calls directly into your application.

It also allows you to easily work with error exceptions being thrown by your API calls.

### Making Internal Requests {#making-internal-request}

---

Making internal requests to your API is pretty easy. Just execute the a restful request as a method on the API alias. The supported methods for internal requests are `GET`, `POST`, `HEAD`, `PUT`, `PATCH` and `DELETE`.

For example, if you had a API route set up to retrieve all the users for your application, you can make an internal call to that API route by using the `get()` method.

	$response = API::get('v1/users');

The response will return an instance of `Cartalyst\Api\Http\Response`.

### Sending Request Parameters {#sending-request-parameters}

---

You can pass along request parameters for your API request by passing along an array of data as the second parameter.

	$data = array(
		'name'  => 'John Doe',
		'email' => 'john.doe@example.com'
	);

	$response = API::post('v1/users', $data);

### Providing A Callback {#providing-a-callback}

---

You can provide a callback which is called after the request has been created and before the request is executed by passing along a closure as the third parameter. An instant of `Cartalyst\Api\Http\Request` (which is an extension of `Illuminate\Http\Request`) is provided to the callback.

	$data = array(
		'name'  => 'John Doe',
		'email' => 'john.doe@example.com'
	);

	$response = API::get('v1/users', $data, function($request)
	{
		// If the request doesn't provides a name input parameter,
		// abort the application with a "Bad request" status code.
		if ( ! $request->has('name'))
		{
			App::abort(400);
		}
	});

### Catching Exceptions {#catching-exceptions}

---

When making internal requests, you can catch error exceptions thrown by the API package. The exception being thrown by the API package is `Cartalyst\Api\Http\ApiHttpException` which extends the `Symfony\Component\HttpKernel\Exception\HttpException` class.

	try
	{
		$response = API::get('v1/users');
	}
	catch (Cartalyst\Api\Http\ApiHttpException $e)
	{
		// Handle exception.
	}

Extending the `Symfony\Component\HttpKernel\Exception\HttpException` class provides you with a few options to handle exceptions.

- You can use `isClientError()` and `isServerError()` to determine the error source.
- Using `getErrors()` will return an array with the errors for the request (as defined by the response generated by the request).
- Using `getMessage()` will provide the message passed along to the response.
- Using `getStatusCode()` will return the HTTP status code returned by the internal request.

Below is an example of how these functions can be used:

	try
	{
		$result = API::get('v1/foo');
	}
	catch (Cartalyst\Api\Http\ApiHttpException $e)
	{
		// When something went wrong on the server end,
		// let's abort the application.
		if ($e->isServerError())
		{
			App::abort($e->getStatusCode());
		}

		// Else if the client did something wrong, redirect back to
		// our previous screen with the errors and message that the
		// response returned.
		elseif ($e->isClientError())
		{
			return Redirect::to('bar')
				->withErrors($e->getErrors())
				->with('message', $e->getMessage());
		}
	}